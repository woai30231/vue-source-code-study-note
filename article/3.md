## 本节阅读指引

通过在阅读vue的源码过程中，我们发现vue源码里面实现了一些我们以前可能经常使用过的经典函数功能，比如函数实现缓存cache、绑定上下文bind及融合对象等！我们发现，我们实现的方式可能与vue中的实现有一些出入，所以这片文档通过学习vue源码中关于一些经典功能的实现方式来对比学习！从而使我们为以后编码优化代码提供一个方向。

##### 经典函数之：cache

其在vue源码实现如下：

```javascript
  /**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}
```

##### 经典函数之：bind函数

其在vue源码中实现如下：

```javascript
  /**
 * Simple bind, faster than native
 */
function bind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn
}
```

##### 经典函数之：宽松比较两个值是否相等

其在vue源码中实现如下：

```javascript
  /**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}
```

##### 经典函数之：保证一个函数只被调用一次

其在vue源码中的实现:

```javascript
  /**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}
```




## 文档未完待续……
